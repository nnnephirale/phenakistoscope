<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proportional Pixel Architect</title>
    <style>
        :root {
            --primary: #4CAF50;
            --primary-hover: #45a049;
            --bg: #f5f5f5;
            --panel-bg: #ffffff;
            --border: #ddd;
            --handle-hover: rgba(0, 0, 255, 0.2);
            --guide: rgba(0, 0, 255, 0.5);
        }

        body {
            font-family: Arial, sans-serif;
            background-color: var(--bg);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* UI Panels */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
        }

        .panel {
            background: var(--panel-bg);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            min-width: 150px;
        }

        .panel h2 {
            font-size: 16px;
            margin: 0 0 10px 0;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        /* Buttons & Inputs */
        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
            margin: 2px;
        }

        button:hover:not(:disabled) { background: var(--primary-hover); }
        button:disabled { background: #ccc; cursor: not-allowed; }
        button.active { outline: 2px solid #000; font-weight: bold; }

        input[type="checkbox"] { vertical-align: middle; }

        /* Grid Area */
        #canvas-wrapper {
            position: relative;
            background: var(--panel-bg);
            padding: 40px; /* Space for handles */
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            min-height: 520px;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

        #grid-container {
            position: relative;
            background-color: #ddd; /* Grid gap color */
            display: grid;
            width: 500px;
            height: 500px;
            overflow: visible;
        }

        .pixel {
            width: 100%;
            height: 100%;
            background-color: #fff;
            cursor: pointer;
            position: relative;
            box-sizing: border-box;
        }

        /* Grid Types */
        #grid-container.type-square { gap: 1px; }
        
        #grid-container.type-circle .pixel { border-radius: 50%; position: absolute; }
        #grid-container.type-hex .pixel { 
            clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
            position: absolute; 
        }
        #grid-container.type-squircle .pixel { border-radius: 30%; position: absolute; }

        /* Grid Visibility */
        .hide-grid-lines { gap: 0 !important; background-color: transparent !important; }
        .hide-grid-lines .pixel { border: none !important; }

        /* Symmetry Guides */
        .guide-v { position: absolute; top: 0; bottom: 0; width: 1px; background: var(--guide); left: 50%; pointer-events: none; z-index: 10; display: none; }
        .guide-h { position: absolute; left: 0; right: 0; height: 1px; background: var(--guide); top: 50%; pointer-events: none; z-index: 10; display: none; }

        /* Handles */
        .handle {
            position: absolute;
            background: transparent;
            z-index: 20;
        }
        .handle:hover { background: var(--handle-hover); }
        .handle-v { width: 20px; cursor: ew-resize; }
        .handle-h { height: 20px; cursor: ns-resize; }

        /* Colors */
        .palette { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
        .swatch { width: 25px; height: 25px; border: 1px solid #ccc; cursor: pointer; }
        .swatch.active { border: 2px solid #000; }

        /* Images */
        #image-list {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
        }
        .thumb { width: 50px; height: 50px; object-fit: cover; border: 1px solid #ccc; cursor: pointer; }
        .thumb.active { border: 2px solid var(--primary); }

        .loading { font-size: 12px; color: #666; font-style: italic; }
    </style>
</head>
<body>

<div class="container">
    <div class="controls">
        <div class="panel">
            <h2>Tools</h2>
            <button id="tool-draw" class="active">Draw</button>
            <button id="tool-erase">Erase</button>
            <button id="tool-fill">Fill</button>
            <button id="btn-clear">Clear All</button>
            <div style="margin-top:10px">
                <button id="btn-undo" disabled>Undo</button>
                <button id="btn-redo" disabled>Redo</button>
            </div>
        </div>

        <div class="panel">
            <h2>Grid</h2>
            <select id="grid-size">
                <option value="8">8 x 8</option>
                <option value="16" selected>16 x 16</option>
                <option value="32">32 x 32</option>
            </select>
            <select id="grid-type">
                <option value="square">Square</option>
                <option value="circle">Circle</option>
                <option value="hex">Hexagon</option>
                <option value="squircle">Squircle</option>
            </select>
            <div style="margin-top:10px">
                <label><input type="checkbox" id="chk-hide-grid"> Hide Lines</label>
            </div>
        </div>

        <div class="panel">
            <h2>Symmetry</h2>
            <label><input type="checkbox" id="sym-v"> Vertical</label><br>
            <label><input type="checkbox" id="sym-h"> Horizontal</label><br>
            <label><input type="checkbox" id="sym-r"> Radial</label>
        </div>

        <div class="panel">
            <h2>Variable Proportions</h2>
            <label><input type="checkbox" id="chk-proportions"> Enable</label>
            <div style="margin-top:5px">
                <button id="btn-rand-prop">Randomize</button>
                <input type="range" id="rand-intensity" min="1" max="5" value="3" style="width:60px">
            </div>
            <button id="btn-reset-prop" style="width:100%">Reset</button>
        </div>

        <div class="panel">
            <h2>Colors</h2>
            <div class="palette" id="palette"></div>
            <div style="margin-top:10px; display: flex; gap: 5px;">
                <input type="color" id="color-custom" value="#000000">
                <button id="btn-add-color">Add</button>
            </div>
        </div>

        <div class="panel" style="width: 240px;">
            <h2>Images</h2>
            <input type="file" id="img-upload" multiple accept="image/*" style="font-size: 11px;">
            <div id="img-loading" class="loading" style="display:none">Processing...</div>
            <div id="image-list"></div>
        </div>
    </div>

    <div id="canvas-wrapper">
        <div id="grid-container" class="type-square">
            <div class="guide-v" id="guide-v"></div>
            <div class="guide-h" id="guide-h"></div>
        </div>
        <div id="handle-container"></div>
    </div>

    <div style="text-align: center;">
        <button id="btn-export" style="padding: 15px 40px; font-weight: bold; font-size: 16px;">EXPORT PNG</button>
    </div>
</div>

<script>
/** * PIXEL ART APPLICATION STATE 
 */
let gridSize = 16;
let gridType = 'square';
let currentTool = 'draw';
let currentColor = '#000000';
let currentImageId = null;
let isDrawing = false;
let gridData = []; // 2D Array of {filled, color, imageId}
let rowSizes = []; // Array of multipliers
let colSizes = []; // Array of multipliers
let images = []; // {id, url, filename}
let history = [];
let historyIndex = -1;

// Dragging Logic
let isResizing = false;
let resizeTarget = null; // {type: 'row'|'col', index: int}
let lastDrawTime = 0;

/** * INITIALIZATION 
 */
function init() {
    setupPalettes();
    resetProportions();
    createGrid(16);
    saveHistory();
    attachEventListeners();
}

function setupPalettes() {
    const defaults = ['#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffa500', '#800080', '#808080', '#006400'];
    const palette = document.getElementById('palette');
    defaults.forEach(color => addSwatch(color));
    selectSwatch(palette.firstChild);
}

function addSwatch(color) {
    const palette = document.getElementById('palette');
    // Prevent duplicates
    const existing = Array.from(palette.children).find(s => s.dataset.color === color);
    if (existing) {
        selectSwatch(existing);
        return;
    }
    const s = document.createElement('div');
    s.className = 'swatch';
    s.style.backgroundColor = color;
    s.dataset.color = color;
    s.onclick = () => selectSwatch(s);
    palette.appendChild(s);
    selectSwatch(s);
}

function selectSwatch(el) {
    document.querySelectorAll('.swatch').forEach(s => s.classList.remove('active'));
    document.querySelectorAll('.thumb').forEach(t => t.classList.remove('active'));
    el.classList.add('active');
    currentColor = el.dataset.color;
    currentImageId = null;
}

/** * GRID CORE 
 */
function createGrid(size) {
    gridSize = size;
    const container = document.getElementById('grid-container');
    
    // Preserve data if exists
    const oldData = gridData;
    gridData = Array(size).fill().map(() => Array(size).fill().map(() => ({filled: false, color: '#fff', imageId: null})));
    
    if (oldData.length > 0) {
        for(let r=0; r<Math.min(size, oldData.length); r++) {
            for(let c=0; c<Math.min(size, oldData[0].length); c++) {
                gridData[r][c] = oldData[r][c];
            }
        }
    }

    // Proportions
    rowSizes = Array(size).fill(1.0);
    colSizes = Array(size).fill(1.0);

    renderGrid();
}

function renderGrid() {
    const container = document.getElementById('grid-container');
    const type = document.getElementById('grid-type').value;
    container.className = `type-${type} ${document.getElementById('chk-hide-grid').checked ? 'hide-grid-lines' : ''}`;
    
    // Clear elements but keep guides
    const guides = [document.getElementById('guide-v'), document.getElementById('guide-h')];
    container.innerHTML = '';
    guides.forEach(g => container.appendChild(g));

    if (type === 'square') {
        container.style.display = 'grid';
        updateGridTemplate();
    } else {
        container.style.display = 'block';
    }

    for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
            const pixel = document.createElement('div');
            pixel.className = 'pixel';
            pixel.dataset.row = r;
            pixel.dataset.col = c;
            
            updatePixelDOM(pixel, r, c);

            pixel.onmousedown = (e) => handlePixelAction(r, c, true);
            pixel.onmouseover = (e) => { if(isDrawing) handlePixelAction(r, c, false); };
            
            container.appendChild(pixel);
        }
    }
    
    if (type !== 'square') positionAbsolutePixels();
    createHandles();
    updateSymmetryGuides();
}

function updatePixelDOM(el, r, c) {
    const data = gridData[r][c];
    const type = document.getElementById('grid-type').value;
    
    el.style.backgroundColor = data.filled ? data.color : '#fff';
    
    if (data.imageId) {
        const img = images.find(i => i.id === data.imageId);
        if (img) {
            el.style.backgroundImage = `url(${img.url})`;
            el.style.backgroundSize = 'cover';
        }
    } else {
        el.style.backgroundImage = 'none';
    }

    // Hex and other shapes handled by CSS classes and positioning
}

function positionAbsolutePixels() {
    const type = document.getElementById('grid-type').value;
    const pixels = document.querySelectorAll('.pixel');
    const containerSize = 500;
    const gap = document.getElementById('chk-hide-grid').checked ? 0 : 2;

    const rowSum = rowSizes.reduce((a, b) => a + b, 0);
    const colSum = colSizes.reduce((a, b) => a + b, 0);

    let currentTop = 0;
    for (let r = 0; r < gridSize; r++) {
        let currentLeft = 0;
        const h = (rowSizes[r] / rowSum) * containerSize;
        
        for (let c = 0; c < gridSize; c++) {
            const w = (colSizes[c] / colSum) * containerSize;
            const idx = r * gridSize + c;
            const p = pixels[idx];
            
            p.style.width = (w - gap) + 'px';
            p.style.height = (type === 'hex' ? (w * 0.866) : (h - gap)) + 'px';
            p.style.left = currentLeft + 'px';
            p.style.top = currentTop + 'px';
            
            currentLeft += w;
        }
        currentTop += h;
    }
}

function updateGridTemplate() {
    if (document.getElementById('grid-type').value !== 'square') return;
    const container = document.getElementById('grid-container');
    const useProp = document.getElementById('chk-proportions').checked;

    if (useProp) {
        container.style.gridTemplateRows = rowSizes.map(s => `${s}fr`).join(' ');
        container.style.gridTemplateColumns = colSizes.map(s => `${s}fr`).join(' ');
    } else {
        container.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;
        container.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
    }
}

/**
 * VARIABLE PROPORTIONS
 */
function createHandles() {
    const hContainer = document.getElementById('handle-container');
    hContainer.innerHTML = '';
    if (!document.getElementById('chk-proportions').checked) return;

    const containerSize = 500;
    const rowSum = rowSizes.reduce((a, b) => a + b, 0);
    const colSum = colSizes.reduce((a, b) => a + b, 0);

    // Vertical handles (adjust column widths) - placed top/bottom
    let currentLeft = 0;
    for (let i = 0; i < gridSize - 1; i++) {
        currentLeft += (colSizes[i] / colSum) * containerSize;
        
        const topH = createHandle('v', i, currentLeft + 40, 20); // +40 for wrapper padding
        const botH = createHandle('v', i, currentLeft + 40, containerSize + 40 + 20);
        hContainer.appendChild(topH);
        hContainer.appendChild(botH);
    }

    // Horizontal handles (adjust row heights) - placed left/right
    let currentTop = 0;
    for (let i = 0; i < gridSize - 1; i++) {
        currentTop += (rowSizes[i] / rowSum) * containerSize;
        
        const leftH = createHandle('h', i, 20, currentTop + 40);
        const rightH = createHandle('h', i, containerSize + 40 + 20, currentTop + 40);
        hContainer.appendChild(leftH);
        hContainer.appendChild(rightH);
    }
}

function createHandle(type, index, x, y) {
    const h = document.createElement('div');
    h.className = `handle handle-${type}`;
    if (type === 'v') {
        h.style.left = (x - 10) + 'px';
        h.style.top = (y - 20) + 'px';
        h.style.height = '20px';
    } else {
        h.style.left = (x - 20) + 'px';
        h.style.top = (y - 10) + 'px';
        h.style.width = '20px';
    }
    
    h.onmousedown = (e) => {
        isResizing = true;
        resizeTarget = { type, index, startX: e.clientX, startY: e.clientY, startVal: type === 'v' ? colSizes[index] : rowSizes[index] };
        e.stopPropagation();
    };
    return h;
}

/**
 * DRAWING LOGIC & SYMMETRY
 */
function handlePixelAction(r, c, isClick) {
    if (currentTool === 'fill' && isClick) {
        const targetColor = gridData[r][c].color;
        const targetFilled = gridData[r][c].filled;
        floodFill(r, c, targetColor, targetFilled);
        saveHistory();
        return;
    }

    const pixelsToApply = getSymmetricPixels(r, c);
    pixelsToApply.forEach(pos => {
        const cell = gridData[pos.r][pos.c];
        if (currentTool === 'draw') {
            cell.filled = true;
            cell.color = currentColor;
            cell.imageId = currentImageId;
        } else if (currentTool === 'erase') {
            cell.filled = false;
            cell.imageId = null;
        }
        
        const el = document.querySelector(`.pixel[data-row="${pos.r}"][data-col="${pos.c}"]`);
        if (el) updatePixelDOM(el, pos.r, pos.c);
    });

    if (isClick && currentTool !== 'fill') saveHistory();
}

function getSymmetricPixels(r, c) {
    const pts = [{r, c}];
    const v = document.getElementById('sym-v').checked;
    const h = document.getElementById('sym-h').checked;
    const rad = document.getElementById('sym-r').checked;

    if (v || rad) pts.push({r, c: gridSize - 1 - c});
    if (h || rad) pts.push({r: gridSize - 1 - r, c});
    if (rad || (v && h)) pts.push({r: gridSize - 1 - r, c: gridSize - 1 - c});
    
    return pts;
}

function floodFill(r, c, targetColor, targetFilled) {
    if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) return;
    const cell = gridData[r][c];
    if (cell.filled === true && cell.color === currentColor && !currentImageId) return;
    if (cell.filled !== targetFilled || (targetFilled && cell.color !== targetColor)) return;

    cell.filled = true;
    cell.color = currentColor;
    cell.imageId = currentImageId;
    
    const el = document.querySelector(`.pixel[data-row="${r}"][data-col="${c}"]`);
    updatePixelDOM(el, r, c);

    floodFill(r + 1, c, targetColor, targetFilled);
    floodFill(r - 1, c, targetColor, targetFilled);
    floodFill(r, c + 1, targetColor, targetFilled);
    floodFill(r, c - 1, targetColor, targetFilled);
}

/**
 * HISTORY SYSTEM
 */
function saveHistory() {
    // Truncate future if we were in the middle of undoing
    history = history.slice(0, historyIndex + 1);
    
    const state = {
        gridData: JSON.parse(JSON.stringify(gridData)),
        rowSizes: [...rowSizes],
        colSizes: [...colSizes],
        gridSize: gridSize,
        gridType: document.getElementById('grid-type').value
    };
    
    history.push(state);
    if (history.length > 30) history.shift();
    historyIndex = history.length - 1;
    updateHistoryButtons();
}

function undo() {
    if (historyIndex > 0) {
        historyIndex--;
        loadHistoryState(history[historyIndex]);
    }
}

function redo() {
    if (historyIndex < history.length - 1) {
        historyIndex++;
        loadHistoryState(history[historyIndex]);
    }
}

function loadHistoryState(state) {
    if (!state) return;
    gridSize = state.gridSize;
    gridData = JSON.parse(JSON.stringify(state.gridData));
    rowSizes = [...state.rowSizes];
    colSizes = [...state.colSizes];
    document.getElementById('grid-size').value = gridSize;
    document.getElementById('grid-type').value = state.gridType;
    renderGrid();
    updateHistoryButtons();
}

function updateHistoryButtons() {
    document.getElementById('btn-undo').disabled = historyIndex <= 0;
    document.getElementById('btn-redo').disabled = historyIndex >= history.length - 1;
}

/**
 * EXPORT SYSTEM
 */
function exportPNG() {
    const canvas = document.createElement('canvas');
    const scale = 2;
    const baseSize = 500 * scale;
    canvas.width = baseSize;
    canvas.height = baseSize;
    const ctx = canvas.getContext('2d');

    // Bg
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, baseSize, baseSize);

    const type = document.getElementById('grid-type').value;
    const rowSum = rowSizes.reduce((a, b) => a + b, 0);
    const colSum = colSizes.reduce((a, b) => a + b, 0);

    let currentTop = 0;
    for (let r = 0; r < gridSize; r++) {
        let currentLeft = 0;
        const h = (rowSizes[r] / rowSum) * baseSize;
        for (let c = 0; c < gridSize; c++) {
            const w = (colSizes[c] / colSum) * baseSize;
            const data = gridData[r][c];

            if (data.filled) {
                ctx.save();
                // Define Path
                if (type === 'circle') {
                    ctx.beginPath();
                    ctx.arc(currentLeft + w/2, currentTop + h/2, Math.min(w,h)/2, 0, Math.PI*2);
                    ctx.clip();
                } else if (type === 'hex') {
                    const hw = w;
                    const hh = w * 0.866;
                    ctx.beginPath();
                    ctx.moveTo(currentLeft + hw*0.25, currentTop);
                    ctx.lineTo(currentLeft + hw*0.75, currentTop);
                    ctx.lineTo(currentLeft + hw, currentTop + hh*0.5);
                    ctx.lineTo(currentLeft + hw*0.75, currentTop + hh);
                    ctx.lineTo(currentLeft + hw*0.25, currentTop + hh);
                    ctx.lineTo(currentLeft, currentTop + hh*0.5);
                    ctx.closePath();
                    ctx.clip();
                } else if (type === 'squircle') {
                    const radius = Math.min(w, h) * 0.3;
                    ctx.beginPath();
                    ctx.moveTo(currentLeft + radius, currentTop);
                    ctx.lineTo(currentLeft + w - radius, currentTop);
                    ctx.quadraticCurveTo(currentLeft + w, currentTop, currentLeft + w, currentTop + radius);
                    ctx.lineTo(currentLeft + w, currentTop + h - radius);
                    ctx.quadraticCurveTo(currentLeft + w, currentTop + h, currentLeft + w - radius, currentTop + h);
                    ctx.lineTo(currentLeft + radius, currentTop + h);
                    ctx.quadraticCurveTo(currentLeft, currentTop + h, currentLeft, currentTop + h - radius);
                    ctx.lineTo(currentLeft, currentTop + radius);
                    ctx.quadraticCurveTo(currentLeft, currentTop, currentLeft + radius, currentTop);
                    ctx.clip();
                }

                if (data.imageId) {
                    const imgObj = images.find(i => i.id === data.imageId);
                    if (imgObj) {
                        const img = new Image();
                        img.src = imgObj.url;
                        ctx.drawImage(img, currentLeft, currentTop, w, h);
                    }
                } else {
                    ctx.fillStyle = data.color;
                    ctx.fillRect(currentLeft, currentTop, w, h);
                }
                ctx.restore();
            }
            currentLeft += w;
        }
        currentTop += h;
    }

    const dataUrl = canvas.toDataURL('image/png');
    const win = window.open();
    win.document.write(`<iframe src="${dataUrl}" frameborder="0" style="border:0; top:0px; left:0px; bottom:0px; right:0px; width:100%; height:100%;" allowfullscreen></iframe>`);
}

/**
 * HELPERS
 */
function resetProportions() {
    rowSizes = Array(gridSize).fill(1.0);
    colSizes = Array(gridSize).fill(1.0);
    renderGrid();
}

function updateSymmetryGuides() {
    document.getElementById('guide-v').style.display = document.getElementById('sym-v').checked || document.getElementById('sym-r').checked ? 'block' : 'none';
    document.getElementById('guide-h').style.display = document.getElementById('sym-h').checked || document.getElementById('sym-r').checked ? 'block' : 'none';
}

/**
 * EVENT LISTENERS
 */
function attachEventListeners() {
    window.addEventListener('mouseup', () => {
        if (isDrawing || isResizing) saveHistory();
        isDrawing = false;
        isResizing = false;
        resizeTarget = null;
    });

    window.onmousemove = (e) => {
        if (!isResizing) return;
        
        // Performance throttle
        const now = Date.now();
        if (now - lastDrawTime < 50) return;
        lastDrawTime = now;

        const delta = resizeTarget.type === 'v' ? e.movementX : e.movementY;
        const sensitivity = 0.05;
        const idx = resizeTarget.index;
        const targetArr = resizeTarget.type === 'v' ? colSizes : rowSizes;

        targetArr[idx] = Math.max(0.1, targetArr[idx] + (delta * sensitivity));
        
        // Handle symmetry in proportions
        if (document.getElementById('sym-v').checked && resizeTarget.type === 'v') {
            targetArr[gridSize - 2 - idx] = targetArr[idx];
        }
        if (document.getElementById('sym-h').checked && resizeTarget.type === 'h') {
            targetArr[gridSize - 2 - idx] = targetArr[idx];
        }

        renderGrid();
    };

    document.getElementById('grid-container').onmousedown = () => { isDrawing = true; };

    // Tool switching
    document.getElementById('tool-draw').onclick = (e) => setActiveTool('draw', e.target);
    document.getElementById('tool-erase').onclick = (e) => setActiveTool('erase', e.target);
    document.getElementById('tool-fill').onclick = (e) => setActiveTool('fill', e.target);
    
    document.getElementById('btn-clear').onclick = () => {
        gridData.forEach(row => row.forEach(cell => { cell.filled = false; cell.imageId = null; }));
        renderGrid();
        saveHistory();
    };

    // Grid config
    document.getElementById('grid-size').onchange = (e) => createGrid(parseInt(e.target.value));
    document.getElementById('grid-type').onchange = renderGrid;
    document.getElementById('chk-hide-grid').onchange = renderGrid;
    document.getElementById('chk-proportions').onchange = renderGrid;

    // Symmetry
    document.getElementById('sym-v').onchange = updateSymmetryGuides;
    document.getElementById('sym-h').onchange = updateSymmetryGuides;
    document.getElementById('sym-r').onchange = updateSymmetryGuides;

    // Randomize Proportions
    document.getElementById('btn-rand-prop').onclick = () => {
        const intensity = parseInt(document.getElementById('rand-intensity').value);
        const max = intensity * 1.6;
        const rand = () => Math.max(0.1, Math.pow(Math.random(), 1.5) * max);
        
        rowSizes = rowSizes.map(() => rand());
        colSizes = colSizes.map(() => rand());
        
        if (document.getElementById('sym-v').checked) colSizes.forEach((v, i) => colSizes[gridSize-1-i] = v);
        if (document.getElementById('sym-h').checked) rowSizes.forEach((v, i) => rowSizes[gridSize-1-i] = v);

        renderGrid();
        saveHistory();
    };
    document.getElementById('btn-reset-prop').onclick = resetProportions;

    // Colors
    document.getElementById('btn-add-color').onclick = () => addSwatch(document.getElementById('color-custom').value);
    
    // History
    document.getElementById('btn-undo').onclick = undo;
    document.getElementById('btn-redo').onclick = redo;

    // Export
    document.getElementById('btn-export').onclick = exportPNG;

    // Image Upload
    document.getElementById('img-upload').onchange = handleImageUpload;
}

function setActiveTool(tool, btn) {
    currentTool = tool;
    document.querySelectorAll('.panel button').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
}

async function handleImageUpload(e) {
    const files = e.target.files;
    if (!files.length) return;
    
    const loading = document.getElementById('img-loading');
    const list = document.getElementById('image-list');
    loading.style.display = 'block';
    list.innerHTML = ''; // Clear previous
    images = [];

    for (const file of files) {
        const img = await processImage(file);
        images.push(img);
        
        const thumb = document.createElement('img');
        thumb.src = img.url;
        thumb.className = 'thumb';
        thumb.onclick = () => {
            document.querySelectorAll('.thumb').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.swatch').forEach(s => s.classList.remove('active'));
            thumb.classList.add('active');
            currentImageId = img.id;
            currentColor = null;
        };
        list.appendChild(thumb);
    }

    loading.style.display = 'none';
    if (list.lastChild) list.lastChild.click(); // Auto-select last
}

function processImage(file) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                let w = img.width;
                let h = img.height;
                const max = 300;
                
                if (w > max || h > max) {
                    if (w > h) { h *= max/w; w = max; }
                    else { w *= max/h; h = max; }
                }
                
                canvas.width = w;
                canvas.height = h;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, w, h);
                
                resolve({
                    id: 'img_' + Math.random().toString(36).substr(2, 9),
                    url: canvas.toDataURL('image/jpeg', 0.85),
                    filename: file.name
                });
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    });
}

// Start
init();
</script>
</body>
</html>