<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Liquid Stack Expansion</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: white; font-family: sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 8px;
            z-index: 10;
        }
        input { margin-top: 10px; color: white; }
        p { margin: 0 0 10px 0; font-size: 14px; opacity: 0.8; }
        #status { font-weight: bold; color: #4caf50; display: none; }
    </style>
</head>
<body>

<div id="ui">
    <p><strong>Step 1:</strong> Select portrait images (recommended).</p>
    <input type="file" id="fileInput" multiple accept="image/*">
    <p id="status" style="margin-top:10px;">Ready.</p>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
import { gsap } from 'https://unpkg.com/gsap@3.12.5/index.js';

// --- 1. SETUP ---
const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- 2. THE SHADER ---
const vertexShader = `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
`;

const fragmentShader = `
    uniform float uTime;
    uniform float uProgress; // 0.0 -> 1.0 (Transition)
    uniform sampler2D uTex1; // Background (Old)
    uniform sampler2D uTex2; // Foreground (New)
    uniform vec2 uResolution;
    uniform float uImageAspect; // Aspect ratio of images

    varying vec2 vUv;

    // --- NOISE FUNCTION (Simplex Noise) ---
    vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
    float snoise(vec2 v){
        const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                 -0.577350269189626, 0.024390243902439);
        vec2 i  = floor(v + dot(v, C.yy) );
        vec2 x0 = v -   i + dot(i, C.xx);
        vec2 i1;
        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
        vec4 x12 = x0.xyxy + C.xxzz;
        x12.xy -= i1;
        i = mod(i, 289.0);
        vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
        + i.x + vec3(0.0, i1.x, 1.0 ));
        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
        m = m*m ;
        m = m*m ;
        vec3 x = 2.0 * fract(p * C.www) - 1.0;
        vec3 h = abs(x) - 0.5;
        vec3 ox = floor(x + 0.5);
        vec3 a0 = x - ox;
        m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
        vec3 g;
        g.x  = a0.x  * x0.x  + h.x  * x0.y;
        g.yz = a0.yz * x12.xz + h.yz * x12.yw;
        return 130.0 * dot(m, g);
    }

    // --- SDF BOX FUNCTION ---
    // Calculates distance to a rectangle
    float sdBox( in vec2 p, in vec2 b ) {
        vec2 d = abs(p)-b;
        return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
    }

    void main() {
        vec2 uv = vUv;
        float ratio = uResolution.x / uResolution.y;

        // 1. COORDINATE SPACE
        // Center UVs so (0,0) is middle of screen
        vec2 centered = uv - 0.5;
        centered.x *= ratio; // Correct for screen aspect ratio

        // 2. DEFINE THE GROWING SHAPE (The "New" Image Container)
        // Box dimensions (Portrait shape approx)
        vec2 boxSize = vec2(0.25, 0.35); 
        
        // Calculate Signed Distance to Box
        float boxDist = sdBox(centered, boxSize);

        // 3. CREATE ORGANIC EDGES
        // We add noise to the box distance.
        // Noise is 0.0 when uProgress is 0.0 (Hard Edges initially)
        // Noise increases as uProgress increases (Melting edges)
        float noiseStrength = smoothstep(0.0, 0.5, uProgress) * 0.15; 
        float noise = snoise(uv * 5.0 + uTime * 0.5) * noiseStrength;
        
        // The effective distance to the shape edge
        float dist = boxDist + noise;

        // 4. ANIMATION LOGIC (Expansion)
        // We compare 'dist' to a threshold. 
        // Threshold moves from positive (mask is small) to negative (mask covers screen)
        // Map uProgress 0->1 to a range that covers the screen
        float expandProgress = (uProgress * 1.5) - 0.2; // -0.2 start (small), 1.3 end (full)
        float mask = 1.0 - smoothstep(expandProgress, expandProgress + 0.05, dist);


        // 5. TEXTURE 1: THE BACKGROUND (Being Pushed)
        // Logic: Push pixels AWAY from center as progress increases
        vec2 bgUV = uv;
        float pushStrength = uProgress * 0.5; // How far to push
        // Vector pointing away from center
        vec2 pushDir = normalize(centered); 
        // Apply push, stronger near center
        bgUV -= pushDir * pushStrength * (1.0 - length(centered)*0.5);
        
        // Add some "liquid wobble" to background so it doesn't look stiff
        bgUV.x += sin(bgUV.y * 10.0 + uTime) * 0.01;
        
        vec4 tex1 = texture2D(uTex1, bgUV);
        // Dim background slightly as it gets pushed
        tex1.rgb *= (1.0 - uProgress * 0.5);


        // 6. TEXTURE 2: THE FOREGROUND (Emerging)
        // Logic: Inverse Scale. It starts "zoomed in" (scale < 1) relative to box,
        // but we want it to look like the *image* is scaling up.
        // Actually, simpler approach: Map the UVs to the box size.
        
        vec2 fgUV = uv;
        // Zoom logic: 
        // At start (uProgress 0), we want the texture to look small? 
        // Actually, per reference, the texture inside the box looks normal, just cropped.
        // But let's add a slight zoom out effect for style.
        float zoom = mix(1.2, 1.0, uProgress);
        fgUV = (fgUV - 0.5) * zoom + 0.5;
        
        vec4 tex2 = texture2D(uTex2, fgUV);


        // 7. THE VOID (Gaps)
        // We want a gap between the background and the foreground.
        // Create a secondary mask that is slightly larger than the foreground mask.
        float voidEdge = smoothstep(expandProgress + 0.1, expandProgress + 0.15, dist);
        // voidEdge is 1.0 outside the gap, 0.0 inside the growing shape
        
        // Combine:
        // Inside 'mask' -> Show Tex2
        // Outside 'mask' but Inside 'Void' -> Show Black
        // Outside 'Void' -> Show Tex1
        
        vec4 finalColor = mix(vec4(0.0, 0.0, 0.0, 1.0), tex1, voidEdge); // Mix BG and Void
        finalColor = mix(finalColor, tex2, mask); // Mix Result and FG

        gl_FragColor = finalColor;
    }
`;

// Default Texture
const placeholderData = new Uint8Array([20, 20, 20, 255]);
const placeholderTex = new THREE.DataTexture(placeholderData, 1, 1, THREE.RGBAFormat);
placeholderTex.needsUpdate = true;

const geometry = new THREE.PlaneGeometry(2, 2);
const uniforms = {
    uTime: { value: 0.0 },
    uProgress: { value: 0.0 },
    uTex1: { value: placeholderTex },
    uTex2: { value: placeholderTex },
    uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
    uImageAspect: { value: 1.0 }
};

const material = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: vertexShader,
    fragmentShader: fragmentShader,
    transparent: true
});

const plane = new THREE.Mesh(geometry, material);
scene.add(plane);

// --- 3. ANIMATION LOOP ---
const clock = new THREE.Clock();
let textures = [];
let currentIndex = 0;
let isAnimating = false;

function animate() {
    requestAnimationFrame(animate);
    uniforms.uTime.value = clock.getElapsedTime();
    renderer.render(scene, camera);
}
animate();

// --- 4. LOGIC ---
document.getElementById('fileInput').addEventListener('change', async (e) => {
    const files = e.target.files;
    if (files.length === 0) return;

    textures = [];
    currentIndex = 0;
    document.getElementById('status').innerText = "Loading...";
    document.getElementById('status').style.display = 'block';

    const loader = new THREE.TextureLoader();
    const promises = Array.from(files).map(file => {
        return new Promise(resolve => {
            loader.load(URL.createObjectURL(file), tex => {
                tex.minFilter = THREE.LinearFilter;
                tex.magFilter = THREE.LinearFilter;
                // Clamp is important for the "Void" effect
                tex.wrapS = THREE.ClampToEdgeWrapping;
                tex.wrapT = THREE.ClampToEdgeWrapping;
                resolve(tex);
            });
        });
    });

    textures = await Promise.all(promises);
    document.getElementById('status').innerText = "Running!";

    // Init
    uniforms.uTex1.value = textures[0];
    uniforms.uTex2.value = textures.length > 1 ? textures[1] : textures[0];
    uniforms.uProgress.value = 0.0;

    runSequence();
});

function runSequence() {
    // Wait before starting transition
    setTimeout(() => {
        if (textures.length < 2) return;

        const nextIndex = (currentIndex + 1) % textures.length;
        uniforms.uTex2.value = textures[nextIndex];

        // Animate Growth
        gsap.to(uniforms.uProgress, {
            value: 1.0,
            duration: 2.0,
            ease: "power2.inOut",
            onComplete: () => {
                // STACKING LOGIC:
                // The transition is done. Tex2 is now covering the screen.
                // We instantly swap Tex2 to become the new Background (Tex1).
                // And reset progress to 0.
                
                uniforms.uTex1.value = textures[nextIndex]; // Old FG becomes BG
                uniforms.uProgress.value = 0.0; // Reset
                
                currentIndex = nextIndex;
                
                // Trigger next loop
                runSequence();
            }
        });

    }, 1500); // Pause duration
}

window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>