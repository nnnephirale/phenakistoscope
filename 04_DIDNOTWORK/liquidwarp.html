<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Constant Liquid Warp</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: white; font-family: sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 8px;
            z-index: 10;
        }
        input { margin-top: 10px; color: white; }
        p { margin: 0 0 10px 0; font-size: 14px; opacity: 0.8; }
        #status { font-weight: bold; color: #4caf50; display: none; }
    </style>
</head>
<body>

<div id="ui">
    <p><strong>Step 1:</strong> Select multiple images.</p>
    <input type="file" id="fileInput" multiple accept="image/*">
    <p id="status" style="margin-top:10px;">Images Loaded! Liquid is active.</p>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
import { gsap } from 'https://unpkg.com/gsap@3.12.5/index.js';

// --- 1. SETUP ---
const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- 2. THE SHADER (CONTINUOUS LIQUID) ---
const vertexShader = `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
`;

const fragmentShader = `
    uniform float uTime;       // Constant flowing time
    uniform float uDispFactor; // 0.0 to 1.0 (Transition Trigger)
    uniform sampler2D uTex1;   // Current Image
    uniform sampler2D uTex2;   // Next Image
    uniform float uRatio;      // Aspect Ratio
    
    varying vec2 vUv;

    // A more complex fluid distortion function
    vec2 getDistortion(vec2 uv, float time, float force) {
        vec2 p = uv - 0.5; // Center coords
        p.x *= uRatio;     // Correct aspect
        
        // Calculate polar coordinates
        float radius = length(p);
        float angle = atan(p.y, p.x);

        // --- THE LIQUID MOTION MATH ---
        // 1. Base "Breathing": Always active.
        // It uses sine waves based on distance from center.
        float breathing = sin(radius * 8.0 - time * 2.0); 
        
        // 2. Transition "Surge": Active only during swap.
        // We multiply the breathing effect heavily during transition.
        float surge = force * 3.0; // Huge multiplier when force > 0
        
        // Combine them:
        // base amplitude (0.05) + surge amplitude
        float amplitude = 0.02 + (surge * 0.15); 
        
        // Distort the radius (distance from center)
        float distRadius = radius + (breathing * amplitude);
        
        // Convert back to Cartesian
        vec2 newUV;
        newUV.x = cos(angle) * distRadius;
        newUV.y = sin(angle) * distRadius;
        
        newUV.x /= uRatio; // Un-correct aspect
        newUV += 0.5;      // Back to 0..1 coordinates
        
        return newUV;
    }

    void main() {
        vec2 uv = vUv;
        
        // Calculate the "Transition Curve"
        // uDispFactor goes 0 -> 1. We want a curve that peaks in the middle.
        // sin(0) = 0, sin(PI/2) = 1, sin(PI) = 0.
        float transitionIntensity = sin(uDispFactor * 3.14159);
        
        // --- CALCULATE WARPED UVS ---
        // Notice we pass uTime into both. They are always moving.
        // We pass 'transitionIntensity' as the "Force" parameter.
        vec2 distortedUV = getDistortion(uv, uTime, transitionIntensity);

        // --- FETCH TEXTURES ---
        vec4 t1 = texture2D(uTex1, distortedUV);
        vec4 t2 = texture2D(uTex2, distortedUV);
        
        // --- GAP / TEARING MASK ---
        // If UVs go outside 0..1, make them transparent (black)
        // This creates the "cutout" shape where the liquid pulls away from edges
        float alpha = 1.0;
        if (distortedUV.x < 0.0 || distortedUV.x > 1.0 || distortedUV.y < 0.0 || distortedUV.y > 1.0) {
            alpha = 0.0;
        }

        // --- MIXING ---
        // We mix based on the transition progress
        vec4 color = mix(t1, t2, uDispFactor);
        
        // Apply alpha (the gaps)
        gl_FragColor = vec4(color.rgb * alpha, 1.0);
    }
`;

// Placeholder setup
const placeholderData = new Uint8Array([20, 20, 20, 255]);
const placeholderTex = new THREE.DataTexture(placeholderData, 1, 1, THREE.RGBAFormat);
placeholderTex.needsUpdate = true;

const geometry = new THREE.PlaneGeometry(2, 2);
const uniforms = {
    uTime: { value: 0.0 },
    uDispFactor: { value: 0.0 },
    uTex1: { value: placeholderTex },
    uTex2: { value: placeholderTex },
    uRatio: { value: window.innerWidth / window.innerHeight }
};

const material = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: vertexShader,
    fragmentShader: fragmentShader
});

const plane = new THREE.Mesh(geometry, material);
scene.add(plane);

// --- 3. ANIMATION LOOP ---
const clock = new THREE.Clock();
const textures = [];
let currentIndex = 0;
let isTransitioning = false;

function animate() {
    requestAnimationFrame(animate);
    
    // 1. UPDATE TIME CONSTANTLY
    // This keeps the liquid moving even when not transitioning
    uniforms.uTime.value = clock.getElapsedTime(); 

    renderer.render(scene, camera);
}
animate();


// --- 4. IMAGE LOADING & TRANSITION LOGIC ---
document.getElementById('fileInput').addEventListener('change', async (e) => {
    const files = e.target.files;
    if (files.length === 0) return;
    
    // Cleanup
    textures.length = 0;
    currentIndex = 0;
    document.getElementById('status').style.display = 'block';

    const loader = new THREE.TextureLoader();
    const loadPromises = Array.from(files).map(file => {
        return new Promise((resolve) => {
            loader.load(URL.createObjectURL(file), (tex) => {
                tex.minFilter = THREE.LinearFilter;
                tex.magFilter = THREE.LinearFilter;
                tex.wrapS = THREE.ClampToEdgeWrapping;
                tex.wrapT = THREE.ClampToEdgeWrapping;
                resolve(tex);
            });
        });
    });

    const loaded = await Promise.all(loadPromises);
    loaded.forEach(t => textures.push(t));

    // Start
    initSlideshow();
});

function initSlideshow() {
    if (textures.length === 0) return;
    
    uniforms.uTex1.value = textures[0];
    uniforms.uTex2.value = textures.length > 1 ? textures[1] : textures[0];
    uniforms.uDispFactor.value = 0.0;

    nextSlideLoop();
}

function nextSlideLoop() {
    // Wait 2 seconds, then trigger transition
    setTimeout(() => {
        if (textures.length < 2) return;

        const nextIndex = (currentIndex + 1) % textures.length;
        uniforms.uTex2.value = textures[nextIndex];
        
        isTransitioning = true;
        
        // Animate the transition value
        gsap.to(uniforms.uDispFactor, {
            value: 1.0,
            duration: 1.8, // Slower transition for liquid feel
            ease: "power2.inOut",
            onComplete: () => {
                // Swap textures internally
                uniforms.uTex1.value = textures[nextIndex];
                uniforms.uDispFactor.value = 0.0;
                currentIndex = nextIndex;
                isTransitioning = false;
                
                // Recurse
                nextSlideLoop();
            }
        });

    }, 2000);
}

window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    uniforms.uRatio.value = window.innerWidth / window.innerHeight;
});

</script>
</body>
</html>