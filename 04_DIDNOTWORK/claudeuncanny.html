<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face-Warper | Low-Poly PS1 Weirdcore</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #222;
            font-family: 'Courier New', monospace;
            color: #fff;
        }

        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            cursor: crosshair;
        }

        #canvas.rotate-mode {
            cursor: grab;
        }

        #canvas.rotate-mode:active {
            cursor: grabbing;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .upload-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: all;
        }

        .upload-btn {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 12px 24px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s;
        }

        .upload-btn:hover {
            background: #00ff00;
            color: #000;
        }

        #fileInput {
            display: none;
        }

        .controls {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff00ff;
            padding: 20px;
            min-width: 280px;
            pointer-events: all;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        .control-section {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 0, 255, 0.3);
        }

        .control-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .section-title {
            color: #00ffff;
            font-size: 12px;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .control-group {
            margin-bottom: 16px;
        }

        .control-group label {
            display: block;
            color: #ff00ff;
            font-size: 11px;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 4px;
        }

        .control-group .value {
            color: #00ff00;
            font-size: 10px;
            text-align: right;
        }

        .toggle-btn {
            width: 100%;
            background: rgba(255, 0, 255, 0.2);
            border: 1px solid #ff00ff;
            color: #ff00ff;
            padding: 8px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
            margin-bottom: 8px;
        }

        .toggle-btn.active {
            background: #ff00ff;
            color: #000;
        }

        .mode-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .mode-btn {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        .mode-btn.active {
            background: #00ffff;
            color: #000;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ffff;
            padding: 12px 20px;
            pointer-events: none;
            color: #00ffff;
            font-size: 10px;
            text-align: center;
            max-width: 600px;
        }

        .mode-indicator {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 255, 0.9);
            color: #000;
            padding: 8px 16px;
            pointer-events: none;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            border: 2px solid #00ffff;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .mode-indicator.visible {
            opacity: 1;
        }

        .undo-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 255, 0, 0.9);
            color: #000;
            padding: 20px 40px;
            pointer-events: none;
            font-size: 24px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 3px;
            border: 3px solid #00ff00;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .undo-indicator.visible {
            opacity: 1;
        }

        .title {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            color: #00ff00;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 2px 2px #ff00ff;
            pointer-events: none;
        }

        .reset-btn {
            width: 100%;
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
            color: #ff0000;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        .reset-btn:hover {
            background: #ff0000;
            color: #000;
        }

        .history-info {
            color: #00ff00;
            font-size: 9px;
            text-align: center;
            margin-top: 8px;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="overlay">
        <div class="title">Face-Warper</div>
        
        <div class="upload-container">
            <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                Upload Portrait
            </button>
            <input type="file" id="fileInput" accept="image/*">
        </div>

        <div class="controls">
            <div class="control-section">
                <div class="section-title">Sculpt Mode</div>
                <div class="mode-buttons">
                    <button class="mode-btn active" id="extrudeBtn">Extrude</button>
                    <button class="mode-btn" id="intrudeBtn">Intrude</button>
                </div>
                <div class="control-group">
                    <label>Brush Size</label>
                    <input type="range" id="brushSize" min="0.05" max="0.5" step="0.01" value="0.15">
                    <div class="value" id="brushSizeValue">0.15</div>
                </div>
                <div class="control-group">
                    <label>Brush Strength</label>
                    <input type="range" id="brushStrength" min="0.01" max="0.3" step="0.01" value="0.05">
                    <div class="value" id="brushStrengthValue">0.05</div>
                </div>
                <button class="reset-btn" id="resetMesh">Reset Mesh</button>
                <div class="history-info" id="historyInfo">History: 0/50</div>
            </div>

            <div class="control-section">
                <div class="section-title">Texture Controls</div>
                <div class="control-group">
                    <label>Offset X (Slide Horizontal)</label>
                    <input type="range" id="offsetX" min="-2" max="2" step="0.01" value="0">
                    <div class="value" id="offsetXValue">0.00</div>
                </div>

                <div class="control-group">
                    <label>Offset Y (Slide Vertical)</label>
                    <input type="range" id="offsetY" min="-2" max="2" step="0.01" value="0">
                    <div class="value" id="offsetYValue">0.00</div>
                </div>

                <div class="control-group">
                    <label>Scale (Zoom)</label>
                    <input type="range" id="scale" min="0.1" max="5" step="0.01" value="1">
                    <div class="value" id="scaleValue">1.00</div>
                </div>

                <div class="control-group">
                    <label>Squash X</label>
                    <input type="range" id="squashX" min="0.1" max="3" step="0.01" value="1">
                    <div class="value" id="squashXValue">1.00</div>
                </div>

                <div class="control-group">
                    <label>Squash Y</label>
                    <input type="range" id="squashY" min="0.1" max="3" step="0.01" value="1">
                    <div class="value" id="squashYValue">1.00</div>
                </div>

                <div class="control-group">
                    <label>Rotation</label>
                    <input type="range" id="rotation" min="0" max="6.28" step="0.01" value="0">
                    <div class="value" id="rotationValue">0.00</div>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">Animation</div>
                <button class="toggle-btn" id="spinToggle">Mesh Spin: OFF</button>
            </div>
        </div>

        <div class="mode-indicator" id="modeIndicator">ROTATE MODE</div>
        <div class="undo-indicator" id="undoIndicator">UNDO</div>

        <div class="instructions">
            <strong>SPACEBAR</strong>: Hold for Rotate Mode | <strong>CMD+Z</strong>: Undo | <strong>CMD+SHIFT+Z</strong>: Redo | <strong>WHEEL</strong>: Scale Texture
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

        // ===== SCENE SETUP =====
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 3;

        const canvas = document.getElementById('canvas');
        const renderer = new THREE.WebGLRenderer({ 
            canvas, 
            antialias: false
        });
        
        const LOW_RES_WIDTH = 320;
        const LOW_RES_HEIGHT = Math.floor(LOW_RES_WIDTH / (window.innerWidth / window.innerHeight));
        renderer.setSize(LOW_RES_WIDTH, LOW_RES_HEIGHT, false);

        // ===== UNDO/REDO SYSTEM =====
        class HistoryManager {
            constructor(maxStates = 50) {
                this.states = [];
                this.currentIndex = -1;
                this.maxStates = maxStates;
            }

            saveState(positions, rotation) {
                this.states = this.states.slice(0, this.currentIndex + 1);
                
                this.states.push({
                    positions: positions.slice(),
                    rotation: { x: rotation.x, y: rotation.y, z: rotation.z }
                });
                
                if (this.states.length > this.maxStates) {
                    this.states.shift();
                } else {
                    this.currentIndex++;
                }
                
                this.updateHistoryInfo();
            }

            undo() {
                if (this.currentIndex > 0) {
                    this.currentIndex--;
                    this.updateHistoryInfo();
                    return this.states[this.currentIndex];
                }
                return null;
            }

            redo() {
                if (this.currentIndex < this.states.length - 1) {
                    this.currentIndex++;
                    this.updateHistoryInfo();
                    return this.states[this.currentIndex];
                }
                return null;
            }

            canUndo() {
                return this.currentIndex > 0;
            }

            canRedo() {
                return this.currentIndex < this.states.length - 1;
            }

            clear() {
                this.states = [];
                this.currentIndex = -1;
                this.updateHistoryInfo();
            }

            updateHistoryInfo() {
                const historyInfo = document.getElementById('historyInfo');
                historyInfo.textContent = `History: ${this.currentIndex + 1}/${this.states.length}`;
            }
        }

        const history = new HistoryManager();

        // ===== CREATE LOW-POLY SPHERE WITH MODIFIABLE GEOMETRY =====
        const segments = 32;
        let geometry = new THREE.SphereGeometry(1, segments, segments);
        
        const originalPositions = geometry.attributes.position.array.slice();
        
        const material = new THREE.MeshBasicMaterial({ 
            color: 0x333333,
            wireframe: false
        });
        
        const sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);

        // Save initial state
        history.saveState(originalPositions, sphere.rotation);

        // ===== BRUSH CURSOR PREVIEW =====
        // Create a ring geometry for the brush cursor
        const brushCursorGeometry = new THREE.RingGeometry(0.95, 1.0, 32);
        const brushCursorMaterial = new THREE.MeshBasicMaterial({
            color: 0xff00ff,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.6,
            depthTest: false // Always render on top
        });
        const brushCursor = new THREE.Mesh(brushCursorGeometry, brushCursorMaterial);
        brushCursor.visible = false;
        scene.add(brushCursor);

        // ===== RAYCASTER FOR MESH INTERACTION =====
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // ===== STATE =====
        let texture = null;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let meshSpin = false;
        let rotateMode = false;
        let sculptMode = 'extrude';
        let sculptStarted = false;
        let currentIntersection = null; // Store current intersection for brush preview

        const controls = {
            offsetX: 0,
            offsetY: 0,
            scale: 1,
            squashX: 1,
            squashY: 1,
            rotation: 0,
            brushSize: 0.15,
            brushStrength: 0.05
        };

        // ===== UNDO/REDO VISUAL FEEDBACK =====
        function showUndoIndicator(text) {
            const indicator = document.getElementById('undoIndicator');
            indicator.textContent = text;
            indicator.classList.add('visible');
            setTimeout(() => {
                indicator.classList.remove('visible');
            }, 300);
        }

        // ===== IMPROVED RAYCASTING - GET CAMERA-FACING INTERSECTION =====
        function getCameraFacingIntersection(intersects) {
            if (intersects.length === 0) return null;
            
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            
            let bestIntersect = null;
            let bestDot = -Infinity;
            
            for (let i = 0; i < intersects.length; i++) {
                const intersect = intersects[i];
                const normal = intersect.face.normal.clone();
                normal.transformDirection(sphere.matrixWorld);
                
                const dot = normal.dot(cameraDirection);
                
                if (dot < 0 && dot < bestDot) {
                    bestDot = dot;
                    bestIntersect = intersect;
                }
            }
            
            return bestIntersect || intersects[0];
        }

        // ===== UPDATE BRUSH CURSOR =====
        function updateBrushCursor(intersect) {
            if (!intersect) {
                brushCursor.visible = false;
                return;
            }

            brushCursor.visible = !rotateMode; // Hide in rotate mode
            
            // Position at intersection point
            brushCursor.position.copy(intersect.point);
            
            // Get surface normal and orient the cursor to it
            const normal = intersect.face.normal.clone();
            normal.transformDirection(sphere.matrixWorld);
            
            // Create a quaternion to align the cursor with the surface normal
            const up = new THREE.Vector3(0, 0, 1);
            const quaternion = new THREE.Quaternion();
            quaternion.setFromUnitVectors(up, normal);
            brushCursor.setRotationFromQuaternion(quaternion);
            
            // Offset slightly along normal to prevent z-fighting
            const offset = normal.multiplyScalar(0.01);
            brushCursor.position.add(offset);
            
            // Scale the cursor based on brush size
            const scale = controls.brushSize;
            brushCursor.scale.set(scale, scale, scale);
            
            // Change color based on mode
            if (sculptMode === 'extrude') {
                brushCursor.material.color.set(0x00ffff); // Cyan for extrude
            } else {
                brushCursor.material.color.set(0xff00ff); // Magenta for intrude
            }
        }

        // ===== KEYBOARD CONTROLS =====
        const modeIndicator = document.getElementById('modeIndicator');
        
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !rotateMode) {
                e.preventDefault();
                rotateMode = true;
                canvas.classList.add('rotate-mode');
                modeIndicator.classList.add('visible');
                brushCursor.visible = false; // Hide brush in rotate mode
            }

            if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                if (history.canUndo()) {
                    const state = history.undo();
                    if (state) {
                        applyHistoryState(state);
                        showUndoIndicator('UNDO');
                    }
                }
            }

            if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key === 'z') {
                e.preventDefault();
                if (history.canRedo()) {
                    const state = history.redo();
                    if (state) {
                        applyHistoryState(state);
                        showUndoIndicator('REDO');
                    }
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                rotateMode = false;
                canvas.classList.remove('rotate-mode');
                modeIndicator.classList.remove('visible');
            }
        });

        // ===== APPLY HISTORY STATE =====
        function applyHistoryState(state) {
            const positions = geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                positions.setXYZ(
                    i,
                    state.positions[i * 3],
                    state.positions[i * 3 + 1],
                    state.positions[i * 3 + 2]
                );
            }
            positions.needsUpdate = true;
            geometry.computeVertexNormals();
            
            sphere.rotation.set(state.rotation.x, state.rotation.y, state.rotation.z);
        }

        // ===== SCULPTING FUNCTION =====
        function sculptMesh(intersectPoint) {
            const positions = geometry.attributes.position;
            const vertex = new THREE.Vector3();
            
            for (let i = 0; i < positions.count; i++) {
                vertex.fromBufferAttribute(positions, i);
                vertex.applyMatrix4(sphere.matrixWorld);
                
                const distance = vertex.distanceTo(intersectPoint);
                
                if (distance < controls.brushSize) {
                    const falloff = 1 - (distance / controls.brushSize);
                    const strength = falloff * controls.brushStrength;
                    
                    const localVertex = new THREE.Vector3();
                    localVertex.fromBufferAttribute(positions, i);
                    
                    const direction = localVertex.clone().normalize();
                    const multiplier = sculptMode === 'extrude' ? 1 : -1;
                    localVertex.add(direction.multiplyScalar(strength * multiplier));
                    
                    positions.setXYZ(i, localVertex.x, localVertex.y, localVertex.z);
                }
            }
            
            positions.needsUpdate = true;
            geometry.computeVertexNormals();
        }

        // ===== MOUSE INTERACTION =====
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
            
            if (!rotateMode && currentIntersection) {
                sculptStarted = true;
                sculptMesh(currentIntersection.point);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            // Update raycasting for brush preview (always, even when not dragging)
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(sphere);
            currentIntersection = getCameraFacingIntersection(intersects);
            
            // Update brush cursor position
            updateBrushCursor(currentIntersection);

            // Handle dragging
            if (!isDragging) return;

            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;

            if (rotateMode) {
                sphere.rotation.y += deltaX * 0.01;
                sphere.rotation.x += deltaY * 0.01;
            } else if (currentIntersection) {
                sculptMesh(currentIntersection.point);
            }

            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            
            if (sculptStarted || rotateMode) {
                const positions = geometry.attributes.position.array;
                history.saveState(positions, sphere.rotation);
                sculptStarted = false;
            }
        });

        canvas.addEventListener('mouseleave', () => {
            if (isDragging && (sculptStarted || rotateMode)) {
                const positions = geometry.attributes.position.array;
                history.saveState(positions, sphere.rotation);
            }
            isDragging = false;
            sculptStarted = false;
            brushCursor.visible = false; // Hide brush when leaving canvas
        });

        // MOUSE WHEEL for texture scaling
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (!texture) return;

            const delta = e.deltaY * -0.001;
            controls.scale = Math.max(0.1, Math.min(5, controls.scale + delta));

            document.getElementById('scale').value = controls.scale;
            document.getElementById('scaleValue').textContent = controls.scale.toFixed(2);
        }, { passive: false });

        // ===== FILE UPLOAD =====
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    texture = new THREE.Texture(img);
                    texture.needsUpdate = true;
                    
                    texture.minFilter = THREE.NearestFilter;
                    texture.magFilter = THREE.NearestFilter;
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.center.set(0.5, 0.5);
                    
                    sphere.material.map = texture;
                    sphere.material.color.set(0xffffff);
                    sphere.material.needsUpdate = true;
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        // ===== UI CONTROLS - SCULPT MODE =====
        document.getElementById('extrudeBtn').addEventListener('click', (e) => {
            sculptMode = 'extrude';
            document.getElementById('extrudeBtn').classList.add('active');
            document.getElementById('intrudeBtn').classList.remove('active');
        });

        document.getElementById('intrudeBtn').addEventListener('click', (e) => {
            sculptMode = 'intrude';
            document.getElementById('intrudeBtn').classList.add('active');
            document.getElementById('extrudeBtn').classList.remove('active');
        });

        document.getElementById('brushSize').addEventListener('input', (e) => {
            controls.brushSize = parseFloat(e.target.value);
            document.getElementById('brushSizeValue').textContent = controls.brushSize.toFixed(2);
        });

        document.getElementById('brushStrength').addEventListener('input', (e) => {
            controls.brushStrength = parseFloat(e.target.value);
            document.getElementById('brushStrengthValue').textContent = controls.brushStrength.toFixed(2);
        });

        document.getElementById('resetMesh').addEventListener('click', () => {
            const positions = geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                positions.setXYZ(
                    i,
                    originalPositions[i * 3],
                    originalPositions[i * 3 + 1],
                    originalPositions[i * 3 + 2]
                );
            }
            positions.needsUpdate = true;
            geometry.computeVertexNormals();
            
            sphere.rotation.set(0, 0, 0);
            
            history.clear();
            history.saveState(originalPositions, sphere.rotation);
        });

        // ===== UI CONTROLS - TEXTURE =====
        document.getElementById('offsetX').addEventListener('input', (e) => {
            controls.offsetX = parseFloat(e.target.value);
            document.getElementById('offsetXValue').textContent = controls.offsetX.toFixed(2);
        });

        document.getElementById('offsetY').addEventListener('input', (e) => {
            controls.offsetY = parseFloat(e.target.value);
            document.getElementById('offsetYValue').textContent = controls.offsetY.toFixed(2);
        });

        document.getElementById('scale').addEventListener('input', (e) => {
            controls.scale = parseFloat(e.target.value);
            document.getElementById('scaleValue').textContent = controls.scale.toFixed(2);
        });

        document.getElementById('squashX').addEventListener('input', (e) => {
            controls.squashX = parseFloat(e.target.value);
            document.getElementById('squashXValue').textContent = controls.squashXValue.toFixed(2);
        });

        document.getElementById('squashY').addEventListener('input', (e) => {
            controls.squashY = parseFloat(e.target.value);
            document.getElementById('squashYValue').textContent = controls.squashY.toFixed(2);
        });

        document.getElementById('rotation').addEventListener('input', (e) => {
            controls.rotation = parseFloat(e.target.value);
            document.getElementById('rotationValue').textContent = controls.rotation.toFixed(2);
        });

        document.getElementById('spinToggle').addEventListener('click', (e) => {
            meshSpin = !meshSpin;
            e.target.textContent = meshSpin ? 'Mesh Spin: ON' : 'Mesh Spin: OFF';
            e.target.classList.toggle('active');
        });

        // ===== ANIMATION LOOP =====
        function animate() {
            requestAnimationFrame(animate);

            if (texture) {
                texture.offset.set(controls.offsetX, controls.offsetY);
                texture.repeat.set(
                    controls.scale * controls.squashX, 
                    controls.scale * controls.squashY
                );
                texture.rotation = controls.rotation;
            }

            if (meshSpin) {
                sphere.rotation.y += 0.005;
            }

            renderer.render(scene, camera);
        }

        animate();

        // ===== RESPONSIVE RESIZE =====
        window.addEventListener('resize', () => {
            const newHeight = Math.floor(LOW_RES_WIDTH / (window.innerWidth / window.innerHeight));
            renderer.setSize(LOW_RES_WIDTH, newHeight, false);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>